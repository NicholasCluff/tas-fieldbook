<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDF Bookmark Analyzer</title>
    <script src="https://unpkg.com/pdfjs-dist@3.11.174/build/pdf.min.js"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: #f5f5f5;
        }
        
        .container {
            background: white;
            border-radius: 8px;
            padding: 30px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        h1 {
            color: #2563eb;
            text-align: center;
            margin-bottom: 30px;
        }
        
        .upload-area {
            border: 2px dashed #d1d5db;
            border-radius: 8px;
            padding: 40px;
            text-align: center;
            margin-bottom: 30px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .upload-area:hover {
            border-color: #2563eb;
            background: #f8fafc;
        }
        
        .upload-area.dragover {
            border-color: #2563eb;
            background: #eff6ff;
        }
        
        .results {
            margin-top: 30px;
        }
        
        .section {
            margin-bottom: 30px;
            padding: 20px;
            border: 1px solid #e5e7eb;
            border-radius: 6px;
            background: #f9fafb;
        }
        
        .section h3 {
            margin-top: 0;
            color: #374151;
        }
        
        .bookmark {
            margin: 8px 0;
            padding: 10px;
            background: white;
            border: 1px solid #e5e7eb;
            border-radius: 4px;
            font-family: monospace;
        }
        
        .bookmark.level-1 { margin-left: 20px; }
        .bookmark.level-2 { margin-left: 40px; }
        .bookmark.level-3 { margin-left: 60px; }
        
        .plan {
            margin: 10px 0;
            padding: 15px;
            background: #ecfdf5;
            border: 1px solid #10b981;
            border-radius: 6px;
        }
        
        .plan-title {
            font-weight: bold;
            color: #047857;
        }
        
        .plan-details {
            color: #6b7280;
            font-size: 0.9em;
            margin-top: 5px;
        }
        
        .log {
            background: #1f2937;
            color: #10b981;
            padding: 20px;
            border-radius: 6px;
            font-family: monospace;
            font-size: 0.85em;
            max-height: 400px;
            overflow-y: auto;
            white-space: pre-wrap;
        }
        
        .status {
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
        }
        
        .status.success { background: #d1fae5; color: #065f46; }
        .status.error { background: #fee2e2; color: #991b1b; }
        .status.warning { background: #fef3c7; color: #92400e; }
        
        .button {
            background: #2563eb;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            margin: 10px 5px;
        }
        
        .button:hover {
            background: #1d4ed8;
        }
        
        pre {
            background: #f3f4f6;
            padding: 15px;
            border-radius: 4px;
            overflow-x: auto;
            font-size: 0.9em;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üìñ PDF Bookmark Analyzer</h1>
        <p style="text-align: center; color: #6b7280;">
            Analyze PDF bookmarks to identify survey plan boundaries
        </p>
        
        <div class="upload-area" id="uploadArea">
            <div>
                üìÑ <strong>Drop PDF file here or click to browse</strong><br>
                <small>Supports PDF files with bookmark/outline structure</small>
            </div>
            <input type="file" id="fileInput" accept=".pdf" style="display: none;">
        </div>
        
        <div id="results" class="results" style="display: none;">
            <div class="section">
                <h3>üìã PDF Information</h3>
                <div id="pdfInfo"></div>
            </div>
            
            <div class="section">
                <h3>üîñ Bookmark Structure</h3>
                <div id="bookmarkStructure"></div>
            </div>
            
            <div class="section">
                <h3>üìã Detected Survey Plans</h3>
                <div id="detectedPlans"></div>
            </div>
            
            <div class="section">
                <h3>üõ†Ô∏è Edge Function Code</h3>
                <p>Copy this improved bookmark analysis code for the edge function:</p>
                <button class="button" onclick="copyEdgeFunctionCode()">üìã Copy Code</button>
                <pre id="edgeFunctionCode"></pre>
            </div>
            
            <div class="section">
                <h3>üîç Debug Log</h3>
                <div class="log" id="debugLog"></div>
            </div>
        </div>
    </div>

    <script>
        // Set up PDF.js worker
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://unpkg.com/pdfjs-dist@3.11.174/build/pdf.worker.min.js';
        
        const uploadArea = document.getElementById('uploadArea');
        const fileInput = document.getElementById('fileInput');
        const results = document.getElementById('results');
        const debugLog = document.getElementById('debugLog');
        
        let debugLogs = [];
        
        function log(message) {
            const timestamp = new Date().toISOString().split('T')[1].split('.')[0];
            const logMessage = `${timestamp}: ${message}`;
            debugLogs.push(logMessage);
            debugLog.textContent = debugLogs.join('\\n');
            debugLog.scrollTop = debugLog.scrollHeight;
            console.log(message);
        }
        
        // File upload handlers
        uploadArea.addEventListener('click', () => fileInput.click());
        
        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.classList.add('dragover');
        });
        
        uploadArea.addEventListener('dragleave', () => {
            uploadArea.classList.remove('dragover');
        });
        
        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
            const files = e.dataTransfer.files;
            if (files.length > 0 && files[0].type === 'application/pdf') {
                analyzePDF(files[0]);
            } else {
                alert('Please drop a PDF file');
            }
        });
        
        fileInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                analyzePDF(e.target.files[0]);
            }
        });
        
        async function analyzePDF(file) {
            try {
                log('=== PDF BOOKMARK ANALYSIS STARTED ===');
                log(`File: ${file.name} (${(file.size / 1024 / 1024).toFixed(2)} MB)`);
                
                // Show results section
                results.style.display = 'block';
                
                // Read file
                const arrayBuffer = await file.arrayBuffer();
                const pdf = await pdfjsLib.getDocument(arrayBuffer).promise;
                
                log(`PDF loaded: ${pdf.numPages} pages`);
                
                // Update PDF info
                document.getElementById('pdfInfo').innerHTML = `
                    <div><strong>Filename:</strong> ${file.name}</div>
                    <div><strong>Pages:</strong> ${pdf.numPages}</div>
                    <div><strong>Size:</strong> ${(file.size / 1024 / 1024).toFixed(2)} MB</div>
                `;
                
                // Get bookmarks/outline
                log('Extracting bookmarks/outline...');
                const outline = await pdf.getOutline();
                
                if (!outline || outline.length === 0) {
                    log('‚ùå No bookmarks found in PDF');
                    document.getElementById('bookmarkStructure').innerHTML = 
                        '<div class="status error">No bookmarks/outline found in this PDF</div>';
                    document.getElementById('detectedPlans').innerHTML = 
                        '<div class="status warning">Cannot detect plans without bookmarks</div>';
                    return;
                }
                
                log(`‚úÖ Found ${outline.length} top-level bookmarks`);
                
                // Parse bookmarks
                const bookmarks = await parseBookmarks(pdf, outline, 0);
                
                // Display bookmark structure
                displayBookmarkStructure(bookmarks);
                
                // Analyze for survey plans
                const plans = analyzePlans(bookmarks, pdf.numPages);
                
                // Display detected plans
                displayPlans(plans);
                
                // Generate edge function code
                generateEdgeFunctionCode(plans, bookmarks);
                
                log('=== ANALYSIS COMPLETE ===');
                
            } catch (error) {
                log(`‚ùå Error: ${error.message}`);
                console.error('PDF analysis error:', error);
            }
        }
        
        async function parseBookmarks(pdf, items, level) {
            const bookmarks = [];
            
            for (const item of items) {
                try {
                    let pageNum = null;
                    
                    if (item.dest) {
                        let dest;
                        if (typeof item.dest === 'string') {
                            dest = await pdf.getDestination(item.dest);
                        } else {
                            dest = item.dest;
                        }
                        
                        if (dest && dest[0]) {
                            const pageIndex = await pdf.getPageIndex(dest[0]);
                            pageNum = pageIndex + 1;
                        }
                    }
                    
                    const bookmark = {
                        title: item.title,
                        page: pageNum,
                        level: level
                    };
                    
                    if (item.items && item.items.length > 0) {
                        bookmark.children = await parseBookmarks(pdf, item.items, level + 1);
                    }
                    
                    bookmarks.push(bookmark);
                    
                } catch (error) {
                    log(`‚ö†Ô∏è Error processing bookmark "${item.title}": ${error.message}`);
                }
            }
            
            return bookmarks;
        }
        
        function displayBookmarkStructure(bookmarks) {
            let html = '';
            
            function renderBookmarks(items, level = 0) {
                for (const bookmark of items) {
                    const indent = '  '.repeat(level);
                    const pageInfo = bookmark.page ? `Page ${bookmark.page}` : 'No page';
                    html += `<div class="bookmark level-${level}">
                        ${indent}üìñ "${bookmark.title}" (${pageInfo})
                    </div>`;
                    
                    if (bookmark.children) {
                        renderBookmarks(bookmark.children, level + 1);
                    }
                }
            }
            
            renderBookmarks(bookmarks);
            document.getElementById('bookmarkStructure').innerHTML = html;
        }
        
        function analyzePlans(bookmarks, totalPages) {
            log('\\n=== ANALYZING BOOKMARKS FOR SURVEY PLANS ===');
            
            // Flatten bookmarks
            const flatBookmarks = [];
            
            function flatten(items) {
                for (const item of items) {
                    if (item.page !== null) {
                        flatBookmarks.push({
                            title: item.title,
                            page: item.page,
                            level: item.level
                        });
                    }
                    if (item.children) {
                        flatten(item.children);
                    }
                }
            }
            
            flatten(bookmarks);
            
            log(`Found ${flatBookmarks.length} bookmarks with valid pages`);
            
            // Simplified: treat every bookmark title as a plan reference
            const detectedPlans = [];
            let currentPlan = null;
            
            for (let i = 0; i < flatBookmarks.length; i++) {
                const bookmark = flatBookmarks[i];
                const planRef = bookmark.title.trim(); // Use the entire title as reference
                
                log(`\\nAnalyzing: "${bookmark.title}" (Page ${bookmark.page})`);
                
                // Check if this is a new plan (different reference) or continuation of current plan
                if (!currentPlan || currentPlan.referenceNumber !== planRef) {
                    // Finalize previous plan if it exists
                    if (currentPlan) {
                        currentPlan.endPage = bookmark.page - 1;
                        currentPlan.pageCount = currentPlan.endPage - currentPlan.startPage + 1;
                        log(`  üìã Finalized plan "${currentPlan.referenceNumber}": Pages ${currentPlan.startPage}-${currentPlan.endPage} (${currentPlan.pageCount} pages)`);
                    }
                    
                    // Start new plan
                    currentPlan = {
                        referenceNumber: planRef,
                        title: `Plan ${planRef}`,
                        startPage: bookmark.page,
                        endPage: totalPages, // Will be updated when next plan starts or at end
                        pageCount: 0, // Will be calculated
                        matchedPattern: 'Any string match',
                        originalTitle: bookmark.title
                    };
                    
                    detectedPlans.push(currentPlan);
                    log(`  ‚úÖ Started new plan: "${planRef}" starting at page ${bookmark.page}`);
                } else {
                    log(`  ‚û°Ô∏è Continuing plan "${planRef}"`);
                }
            }
            
            // Finalize the last plan
            if (currentPlan) {
                currentPlan.endPage = totalPages;
                currentPlan.pageCount = currentPlan.endPage - currentPlan.startPage + 1;
                log(`\\nüìã Finalized last plan "${currentPlan.referenceNumber}": Pages ${currentPlan.startPage}-${currentPlan.endPage} (${currentPlan.pageCount} pages)`);
            }
            
            log(`\\n=== DETECTION SUMMARY ===`);
            log(`Plans detected: ${detectedPlans.length}`);
            
            return detectedPlans;
        }
        
        function displayPlans(plans) {
            let html = '';
            
            if (plans.length === 0) {
                html = '<div class="status warning">No survey plans detected from bookmarks</div>';
            } else {
                for (let i = 0; i < plans.length; i++) {
                    const plan = plans[i];
                    html += `
                        <div class="plan">
                            <div class="plan-title">Plan ${i + 1}: ${plan.referenceNumber}</div>
                            <div class="plan-details">
                                Title: ${plan.title}<br>
                                Pages: ${plan.startPage}-${plan.endPage} (${plan.pageCount} pages)<br>
                                Matched Pattern: ${plan.matchedPattern}<br>
                                Source: ${plan.originalTitle}
                            </div>
                        </div>
                    `;
                }
            }
            
            document.getElementById('detectedPlans').innerHTML = html;
        }
        
        function generateEdgeFunctionCode(plans, bookmarks) {
            const code = `// Improved bookmark analysis for edge function
async function extractPlansFromBookmarks(pdfDoc) {
  // This is a placeholder - in actual edge function, use appropriate PDF.js calls
  // Based on analysis of your PDF:
  // - ${bookmarks.length} total bookmarks found
  // - ${plans.length} survey plans detected
  
  const plans = [
${plans.map(plan => `    {
      referenceNumber: "${plan.referenceNumber}",
      title: "${plan.title}",
      startPage: ${plan.startPage},
      endPage: ${plan.endPage},
      pageCount: ${plan.pageCount}
    }`).join(',\\n')}
  ];
  
  return plans;
}

// Pattern matching logic (working):
const patterns = [
  { name: 'Tasmania format', regex: /\\\\b(\\\\d{6}-\\\\d+)\\\\b/i },
  { name: 'LTO Plan', regex: /\\\\bLTO[\\\\s-]*(\\\\d+)\\\\b/i },
  { name: 'Deposited Plan', regex: /\\\\bDP[\\\\s-]*(\\\\d+)\\\\b/i },
  { name: '6-digit number', regex: /\\\\b(\\\\d{6})\\\\b/i }
];`;

            document.getElementById('edgeFunctionCode').textContent = code;
        }
        
        function copyEdgeFunctionCode() {
            const code = document.getElementById('edgeFunctionCode').textContent;
            navigator.clipboard.writeText(code).then(() => {
                alert('Code copied to clipboard!');
            });
        }
    </script>
</body>
</html>